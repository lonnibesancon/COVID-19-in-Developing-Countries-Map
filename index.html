<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"/>
<script src="https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://npmcdn.com/csv2geojson@latest/csv2geojson.js"></script>

<style>
    body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
    }
    h1{
        padding: 2px;
        text-align: center;
        font-size: 1.6em;
    }
    h2{
        text-align: center;
        font-size: 1.3em;
    }
    .inline {
        display: inline;
        vertical-align:top;
        text-align: left;
    }
    p{
        margin: 2em;
    }
    table{
        margin-top: 10px;
    }

    #main_part{
        display: flex;
    }

    #controls{
        text-align: center;
    }

    #map{
        height: 100%;
        width: 100%;
    }

    #map_container {
        position: relative;
        height: 800px;
        width: 100%;
        margin-top: 1em;
        float: bottom;
        bottom: 0px;
        /*top: 870px;   /*TODO:  fix;*/
    }

    fieldset{
        border-width: 0;
        margin: 0;
    }
    .input_ui{
        margin-left: 2em;
        margin-bottom: 0.5em;
        margin-top: 0.2em;
        width: 100%;
    }

    .tooltip{
        z-index: 100;
    }
    .dots{
        stroke: black;
        stroke-width: 0.5px;
    }
    .national{
        stroke: white;
        stroke-width: 4px;
    }
    .legend{
        z-index: 120;
    }
    .legend_text_header{
        font-size: 1.3em;
    }
    .legend_text_sub{
        font-size: 1.1em;
    }

    #forest_plot_div{
        position: absolute;
    }

    .hovered{
        stroke: pink;
        stroke-width: 2px;
    }

    .risk_td{
        margin: 6%;
        padding-left: 5%;
    }
    .risk_th{
        margin: 6%;
    }

    .float-container {
        margin: auto;
    }

    .float-child{
        width: 48.5%;
        min-width: 420px;
        float: left;
    }  

    .float-child-right{
        width: 54%;
    }
    
    #studyInfo{
        float: bottom;
        min-height: 350px;
    }



    .header{
        margin: 0.3em;
        padding: 0.1em;
        margin-bottom: 0.7em;
        text-align: center;
        font-size: 1.3em;
        width: 100%;
    }

    .sub_header{
        margin-bottom: 0.3em;
        padding: 0.1em;
        font-size: 1.07em;
    }

    #main{
        display: flex;
        width: 100%;
        height: 1000px;
        flex-direction: column;
    }
    #top_left{
        width: 49%;
        min-width: 450px;
    }
    #top_right{
        width: 49%;
        overflow-y: scroll;
    }
    #top_container{
        display: inline-flex;
        width: 100%;
        height: 600px;
        margin-bottom: 50px;
    }
    #bottom_left{
        width: 40%;
        min-width: 400px;
        display: flex;
        height: 600px;

        flex-direction: column;
    }
    #bottom_right{
        width: 100%;
        min-width: 60%;
    }
    #bottom_container{
        display: inline-flex;
        width: 100%;
        height: 600px;
        margin-top: 1px;
    }
    #forest_plot{
        height: 100%;
        width: 100%;
        min-width: 420px;
        min-height: 600px;
    }

    #mapLegend{
        width: 100%;
        height: 200px;
        margin-top: 1px;
        display: inline-flex;
    }

    #left_legend{
        width: 60%;
        min-width: 60%;
        height: 100%;
    }
    #right_legend{
        width: 40%;
        max-width: 40%;
    }
    .legend_dots{
        display: block;
        max-height: 100%;
        heigh: 100%;
        width: 100%;
        max-width: 100%;
    }
    #gradient_legend_svg{
        display: block;
        margin: auto;
    }
    #svg_gradient{
        display: block;
        margin: auto;
        width: 60px;
    }
    .legend_text{
        font-size: 1em;
    }
    .td_info{
        height: 36px;
    }

</style>
</head>
  <body>
    <div id="Text">
        <h1> Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications </h1>
        <h2> Interactive map of all included studies </h2>
        <p>This map displays the location and seroprevalence of all the studies included in our paper "<a href="https://www.medrxiv.org/content/10.1101/2021.09.29.21264325v1.full-text">Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications.</a>"<br> You can place your cursor over a study for more information (on the forest plot or the map) to get more information about the study.</p>
    </div>

    <div id="main">
        <div id="top_container">
            <div id="top_left">
                <svg width="400" height="600" id="forest_plot"></svg>
            </div>
            <div id="top_right">
                <div id="allUI">
                    <div id="data_to_show">
                        Data to visualise: 
                            <select name="encodeVariable" id="encodeVariable" onchange="changeEncodeVariable()"> 
                            </select> 
                    </div>
                    <span class="sub_header">Assay Starts:</span><br/>
                    <div id="date_div_start" class="input_ui">
                        <table>
                            <tr>
                                <td>Min Date</td> 
                                <td><input type="date" id="minDateInputStart" name="minDateInputStart" onchange="changeMinStart()" value="2018-11-23"></td>
                            </tr>
                            <tr>
                                <td>Max Date</td> 
                                <td><input type="date" id="maxDateInputStart" name="maxDateInputStart" onchange="changeMaxStart()" value="2020-11-23"><br/></td>
                            </tr>
                        </table>
                    </div>
                    <span class="sub_header">Assay Ends:</span><br/>
                    <div id="date_div_end" class="input_ui">
                        Min Date <input type="date" id="minDateInputEnd" name="minDateInputEnd" onchange="changeMinEnd()" value="2018-11-23"><br/>
                        Max Date <input type="date" id="maxDateInputEnd" name="maxDateInputEnd" onchange="changeMaxEnd()" value="2020-11-23"><br/>
                    </div>
                    <span class="sub_header">Data location (uncheck to exclude):</span>
                    <fieldset class="inline input_ui">
                        <!--<legend>Data location (uncheck to exclude):</legend>-->
                        <div>
                          <input type="checkbox" id="national" name="national" checked onchange="changeNational()">
                          <label for="national">National</label>
                        </div>
                        <div>
                          <input type="checkbox" id="local" name="local" checked onchange="changeLocal()">
                          <label for="local">Local (city or county)</label>
                        </div>
                    </fieldset>

                    <span class="sub_header">Data Source (uncheck to exclude):</span>
                    <fieldset class="inline input_ui">
                        <!--<legend>Data Source (uncheck to exclude):</legend>-->
                        <div>
                          <input type="checkbox" id="Age-specific-IFR" name="Age-specific-IFR" checked onchange="changeAgeIFR()">
                          <label for="Age-specific-IFR">Age-specific-IFR</label>
                        </div>
                        <div>
                          <input type="checkbox" id="Population-IFR" name="Population-IFR" checked onchange="changePopulationIFR()">
                          <label for="Population-IFR">Population-IFR</label>
                        </div>
                        <div>
                          <input type="checkbox" id="Age-specific-Prevalence" name="Age-specific-Prevalence" checked onchange="changeAgePrevalence()">
                          <label for="Age-specific-Prevalence">Age-specific-Prevalence</label>
                        </div>
                        <div>
                            <input type="checkbox" id="Overall-Prevalence" name="Overall-Prevalence" checked onchange="changeOverallPrevalence()">
                            <label for="Overall-Prevalence">Overall-Prevalence</label>
                        </div>
                    </fieldset>
                    <span class="sub_header">Bias risks (uncheck to exclude):</span>
                    <fieldset class="inline input_ui">
                        <!--<legend>Bias risks (uncheck to exclude):</legend>-->
                        <table style="width: 90%">
                            <tr>
                                <th class="risk_th">Non Response</th>
                                <th class="risk_th">Seroreversion</th> 
                                <th class="risk_th">Death Undercount</th>
                            </tr>
                            <tr>

                                <td class="risk_td"><input type="checkbox" id="NRR_high" name="NRR" checked onchange="changeNRR()">
                                <label for="NRR_high">High</label></td>
                                <td class="risk_td"><input type="checkbox" id="SR_high" name="SR" checked onchange="changeSR()">
                                <label for="SR_high">High</label></td>
                                <td class="risk_td"><input type="checkbox" id="DU_high" name="DU" checked onchange="changeDU()">
                                <label for="DU_high">High</label></td>
                            </tr>
                            <tr>

                                <td class="risk_td"><input type="checkbox" id="NRR_low" name="NRR" checked onchange="changeNRR()">
                                <label for="NRR_low">Low </label></td>                        
                                <td class="risk_td"><input type="checkbox" id="SR_low" name="SR" checked onchange="changeSR()">
                                <label for="SR_low">Low </label></td>
                                <td class="risk_td"><input type="checkbox" id="DU_low" name="DU" checked onchange="changeDU()">
                                <label for="DU_low">Low </label></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td></td>
                                <td class="risk_td"><input type="checkbox" id="DU_NA" name="DU" checked onchange="changeDU()">
                                <label for="DU_NA">NA  </label></td>
                            </tr>

                        </table>
                    </fieldset>
                </div>
            </div>
        </div>
        <div id="bottom_container">
            <div id="bottom_left">
                <div id="studyInfo" class="studyInfo">
                    <p class="header"> Study Info </p>
                    <table>
                        <tr>
                            <td class="legend_text td_info">Location:</td>
                            <td id="locationInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">Type:</td>
                            <td id="typeInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">Seroprevalence:</td>
                            <td id="seroprevalenceInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">IFR:</td>
                            <td id="IFRInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">Assay Name:</td>
                            <td id="assayInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">Dates:</td>
                            <td id="datesInfo" class="legend_text"></td>
                        </tr>
                        <tr>
                            <td class="legend_text td_info">Sources:</td>
                            <td id="sourcesInfo" class="legend_text"></td>
                        </tr>
                    </table>
                </div>
                <div>
                    <p class="header">Legend:</p>
                    <div id="mapLegend">
                        <div id="left_legend">
                            <span class="sub_header">Study type</span>
                            <table>
                                <tr>
                                    <td id="legend_shape1"></td>
                                    <td class="legend_text">Age Specific IFR</td>
                                </tr>
                                <tr>
                                    <td width="30px" height="auto" id="legend_shape2"></td>
                                    <td class="legend_text">Population IFR</td>
                                </tr>
                                <tr>
                                    <td width="30px" height="auto" id="legend_shape3"></td>
                                    <td class="legend_text">Age Specific Prevalence</td>
                                </tr>
                                <tr>
                                    <td width="30px" height="auto" id="legend_shape4"></td>
                                    <td class="legend_text">Overall Prevalence</td>
                                </tr>
                            </table>
                        </div>
                        <div id="right_legend">
                            <center><span id="gradient_legend">Seroprevalence</span></center>
                            <center><div id="gradient_legend_svg"></div></center>
                        </div>
                    </div>
                </div>

            </div>
            <div id="bottom_right">
                <div id="map"></div>
            </div>
        </div>        
    </div>
    <div id="controls">
        <div id="inclusion">
            
        </div>
    </div>
    
    <script>



        /****** Data handling functions & variables*****/
        var initial_data ;
        var data_to_display ;
        var include_age_specific_IFR = true ; 
        var include_population_IFR = true ;
        var include_overall_prevalence = true ;
        var include_age_specific_prevalence = true ;

        var include_national = true ;
        var include_local = true ;

        var include_uniform = true ;
        var include_decreasing = true ;
        var include_increasing = true ;

        var include_DU = [true, true, true]   //We include both high, low, and NA
        var include_SR = [true, true]         //We include both high and low
        var include_NRR = [true, true]   //We include both high and low

        const encode_national_studies = false

        var possible_focus = ["Seroprevalence","IFR"]
        var possible_properties = ["mean","IFR_mean"] 

        var focus_elem = document.getElementById("encodeVariable")
        for(i in possible_focus) {focus_elem.add(new Option(possible_focus[i],possible_focus[i]));}

        var variable_focus = possible_focus[0]

        var min_date_start = null
        var max_date_start = null
        var min_date_end = null 
        var max_date_end = null 

        var max_ci_IFR, max_IFR, max_CI_seroprevalence, max_seroprevalence;



        const age_specific_ifr = "Age-Specific IFR"
        const population_ifr = "Population IFR"
        const age_specific_prevalence = "Age-Specific Prevalence"
        const overall_prevalence = "Overall Prevalence"

        function changeAgeIFR() {
            include_age_specific_IFR = !include_age_specific_IFR
            filterData()
        }
        function changeAgePrevalence(){
            include_age_specific_prevalence = !include_age_specific_prevalence
            filterData()
        }
        function changeOverallPrevalence(){
            include_overall_prevalence = !include_overall_prevalence
            filterData()
        }
        function changePopulationIFR(){
            include_population_IFR = !include_population_IFR
            filterData()
        }
        function changeNational(){
            include_national = !include_national
            filterData()
        }
        function changeLocal(){
            include_local = !include_local
            filterData()
        }
        function changeUniform(){
            include_uniform = !include_uniform
            filterData()
        }
        function changeDecreasing(){
            include_decreasing = !include_decreasing
            filterData()
        }
        function changeIncreasing(){
            include_increasing = !include_increasing
            filterData()
        }

        function changeNRR(){
            var radios = document.getElementsByName("NRR");
            for (var i = 0 ; i < radios.length ; i++) {
               include_NRR[i] = radios[i].checked
            }
            filterData()
        }

        function changeDU(){
            var radios = document.getElementsByName("DU");
            for (var i = 0 ; i < radios.length ; i++) {
               include_DU[i] = radios[i].checked
            }
            filterData()
        }

        function changeSR(){
            var radios = document.getElementsByName("SR");
            for (var i = 0 ; i < radios.length ; i++) {
               include_SR[i] = radios[i].checked
            }
            filterData()
        }


        function changeMinStart(){
            let v = document.getElementById("minDateInputStart").value;
            min_date_start = parseISODate(v);
            filterData();
        }

        function changeMinEnd(){
            let v = document.getElementById("minDateInputEnd").value;
            min_date_end = parseISODate(v);
            filterData();
        }

        function changeMaxStart(){
            let v = document.getElementById("maxDateInputStart").value;
            max_date_start = parseISODate(v);
            filterData();
        }
        function changeMaxEnd(){
            let v = document.getElementById("maxDateInputEnd").value;
            max_date_end = parseISODate(v);
            filterData();
        }

        //Custom sort function 
        function sortBy(field) {
            return function(a, b) {
                //console.log("a.properties[field] = "+a.properties[field])
                //console.log("b.properties[field] = "+b.properties[field])
                if(a.properties[field] > b.properties[field]){
                    //console.log("Return a > b")
                    return -1 
                }         
                else if(a.properties[field] > b.properties[field]){
                    //console.log("Return a < b")
                    return 1
                }
                else{
                    //console.log("Return a = b")
                    return 0
                }
                //return (a.properties[field] > b.properties[field]) - (a.properties[field] < b.properties[field])
            };
        }


        // Parse and validate a date in format yyyy-mm-dd
        // Note that a date without a timezone is treated as LOCAL since
        // the HTML spec is consistent with ISO 8601
        function parseISODate(s){
            var b = s.split(/\D/);
            var d = new Date(b[0], --b[1], b[2]);
            return d && d.getMonth() == b[1]? d : new Date(NaN);
        }

        function changeEncodeVariable(){
            var value = focus_elem.options[focus_elem.selectedIndex].value;
            //Seroprevalence, column mean
            variable_focus = value
            if (variable_focus == possible_focus[0]){

            }
            else{

            }
            updateLegendAndScales(variable_focus)
            filterData()
        }

        //Returns false if the element is not between specified dates
        function filterByDate(elem){
            if( elem.properties.start_date < min_date_start || elem.properties.start_date > max_date_start){
                return false
            }
            if( elem.properties.end_date < min_date_end || elem.properties.end_date > max_date_end){
                return false
            }
            return true 
        }

        function checkSingleBiasRisk(elem,risk_include_values,risk_name){
            let values = ["High","Low","NA"]
            for (var i = 0 ; i < risk_include_values.length ; i++){
                if(risk_include_values[i] == false && elem[risk_name] == values[i]){
                    console.dir(elem)
                    return false
                }
            }
            return true ;
        }

        //Returns false if the element is not within the wanted risk
        function filterRisk(elem){
            elem = elem.properties
            let value = checkSingleBiasRisk(elem,include_DU,"death_undercount_risk") & checkSingleBiasRisk(elem,include_SR,"seroreversion_risk") & checkSingleBiasRisk(elem,include_NRR,"non_response_risk") 
            return value
        }

        function filterData(){
            data_to_display =  []
            for(var i = 0 ; i < initial_data.features.length ; i++){
                let elem = initial_data.features[i]
                if(include_age_specific_IFR == false && elem.properties.study_info == age_specific_ifr){
                    continue
                }
                if(include_population_IFR == false && elem.properties.study_info == population_ifr){
                    continue
                }
                if(include_age_specific_prevalence == false && elem.properties.study_info == age_specific_prevalence){
                    continue                 
                }
                if(include_overall_prevalence == false && elem.properties.study_info == overall_prevalence){
                    continue
                }
                if(include_local == false && elem.properties.location_label != "National Study"){
                    continue
                }
                if(include_national == false && elem.properties.location_label == "National Study"){
                    continue
                }

                //If we focus on Seroprevalece, no problem, but if we focus on IFR, some elements won't have a value, we should remove them
                if(variable_focus == possible_focus[1]){
                    if(elem.properties.IFR_mean == null){
                        continue
                    }
                }

                if(filterRisk(elem) == false){
                    continue
                }


                if(filterByDate(elem) == false){
                    continue 
                }
                data_to_display.push(elem)
            }

            console.log("Pre-sort")
            console.dir(data_to_display)
            if(variable_focus == possible_focus[0]){
                data_to_display.sort(sortBy('mean'));
            }
            else{
                data_to_display.sort(sortBy('IFR_mean'));
            }
            console.log("Post-sort")
            console.dir(data_to_display)
            createDots(data_to_display)
            createForest(data_to_display)

        }

        function create_date(input_string){
            input_string = input_string.split("/")
            let day = +input_string[1]
            let month = +input_string[0]
            let year = +input_string[2]
            let date = new Date(year, month, day)
            return date
        }

        function initialize_max_min_dates(type,date){
            if(type=="start"){
                if(min_date_start == null){
                    min_date_start = date
                }
                if(max_date_start == null){
                    max_date_start = date
                }
                if(date < min_date_start){
                    min_date_start = date
                }
                if(date > max_date_start){
                    max_date_start = date
                }
            }
            else{
                if(min_date_end == null){
                    min_date_end = date
                }
                if(max_date_end == null){
                    max_date_end = date
                }
                if(date < min_date_end){
                    min_date_end = date
                }
                if(date > max_date_end){
                    max_date_end = date
                }
            }
        }


        function parseDates(data){
            for (var i = 0 ; i < data.features.length ; i++){
                let elem = data.features[i].properties
                let date = create_date(elem.start_date)
                elem.start_date = date
                initialize_max_min_dates("start",date)

                date = create_date(elem.end_date)
                elem.end_date = date 
                initialize_max_min_dates("end",date)
            }

            document.getElementById("minDateInputStart").value = (toISOString(min_date_start).substr(0,10))
            document.getElementById("maxDateInputStart").value = (toISOString(max_date_start).substr(0,10))
            document.getElementById("minDateInputEnd").value = (toISOString(min_date_end).substr(0,10))
            document.getElementById("maxDateInputEnd").value = (toISOString(max_date_end).substr(0,10))
        }


        /* This function will be called instead of the function in the Date object that does not leave the time in local timezone.*/
        function toISOString(date) {
          var tzo = -date.getTimezoneOffset(),
              dif = tzo >= 0 ? '+' : '-',
              pad = function(num) {
                  var norm = Math.floor(Math.abs(num));
                  return (norm < 10 ? '0' : '') + norm;
              };

          return date.getFullYear() +
              '-' + pad(date.getMonth() + 1) +
              '-' + pad(date.getDate()) +
              'T' + pad(date.getHours()) +
              ':' + pad(date.getMinutes()) +
              ':' + pad(date.getSeconds()) +
              dif + pad(tzo / 60) +
              ':' + pad(tzo % 60);
        }

        function toShortString(date){
            return (date.getFullYear()+"/"+(date.getMonth()+1)+"/"+date.getDate())
        }


        /****** D3 bits*****/


        var color1 = "rgba(255,255,255,0.85)"
        var color2 = "rgba(165,15,21,0.85)"

        var tooltip_ref_point_coordinates = null ;

        var colorScale = d3.scaleLinear()
            .range([color1, color2]); //"rgba(103,0,13,0.8)"]);

        var max_value = 100

        var tooltipXOffset = 10 ;
        var tooltipYOffset = -50 ;

        var clickedData = false ;

        var display_study_type = true ;
        var offsetYTooltip = document.getElementById("Text").clientHeight + document.getElementById("controls").clientHeight;
        //var offsetYTooltip = document.getElementById("Text").offsetHeight + document.getElementById("controls").offsetHeight;

        var formatNumber = d3.format('.2f');

        var map_style = "positron"

        var transition_time = 700

        let style_link,legend_color,text_color,stroke_color

        if(map_style == "positron"){
            style_link = "https://api.maptiler.com/maps/positron/style.json"
            legend_color = "rgba(195,200,202,0.8)"
            text_color = 'rgba(0,0,0,1)'
        }

        if(map_style == "dark_matter"){
            style_link = "https://api.maptiler.com/maps/darkmatter/style.json"
            legend_color = "rgba(0,0,0,0.8)"
            text_color = 'rgba(255,255,255,1)'
        }

        style_link+="?key=vzWoiH8YygJqMjY0TcSt "

        var forest_valueScale 
        var forest_positionScale 

        var forest_plot



        function updateLegendAndScales(value_for_gradient){
            let tmp = document.getElementById('gradient_legend')
            tmp.textContent = value_for_gradient + " (in %)"
            tmp = document.getElementById('legend_gradient_max')
            let max_ci,max;
            if(variable_focus == possible_focus[0]){
                max_ci = max_ci_seroprevalence
                max = max_seroprevalence
            }
            else{
                max_ci = max_ci_IFR
                max = max_IFR
            }

            
            colorScale.domain([0,max]);
            forest_valueScale.domain([0,max_ci])

            max = parseFloat(max).toFixed(2)
            tmp.textContent = ""+max+"%"

            //d3.select("#forest_x_axis").call(d3.axisLeft(forest_positionScale))
            console.log("Axis print")
            console.dir(d3.selectAll("#forest_x_axis"))
            d3.selectAll("#forest_x_axis")
                .transition().duration(transition_time)
                .call(d3.axisBottom(forest_valueScale));
        }

        var Tooltip = d3.select("#map")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("background-color", "pink")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")
                .style("position","absolute")
        
        
        
        var mouseClickMap = function(d) {
            if(!clickedData){
                Tooltip.style("opacity", 0)    
                tooltip_ref_point_coordinates = null ;
            }
            clickedData = false ;
            
        }

        

        /****** Map bits*****/
        

        var map;


        /****** Display code *****/

        d3.csv("https://raw.githubusercontent.com/covid-ifr/assessing-burden/main/map/map_data.csv", d3.autoType)
            .then(function(data){
                initial_data = JSON.parse(JSON.stringify(data))
                //initial_data = data
                max_ci_seroprevalence= d3.max(initial_data, function(d) {  return +d["p975"]; });
                max_ci_IFR= d3.max(initial_data, function(d) {  return +d["IFR_p975"]; });
                max_seroprevalence= d3.max(initial_data, function(d) {  return +d["mean"]; });
                max_IFR= d3.max(initial_data, function(d) {  return +d["IFR_mean"]; });
                colorScale.domain([0,max_seroprevalence]);
                createLegendFinal()
                createMap()
                createForestPlot()
                makeGeoJson(data)
                parseDates(initial_data)
                return ;
            })

        function createMap() {
            map = new maplibregl.Map({
            container: "map", // container id
            //style: "https://api.maptiler.com/maps/darkmatter/style.json?key=vzWoiH8YygJqMjY0TcSt",
            style: style_link,
            zoom: 1.8, // starting zoom
            maxZoom: 10.2,
            });


            map.on("viewreset", render);
            map.on("move", render);
            map.on("moveend", render);

            // Optional: Modify map with d3
            d3.selectAll(".mapboxgl-canvas")
              .style("opacity", 1)
              .style("position", "absolute")
              .style("z-index", 1);

            var container = map.getCanvasContainer();
            var svg = d3
                .select(container)
                .append("svg")
                .attr("width", "100%")
                .attr("height", "2000")
                .style("position", "absolute")
                .style("z-index", 10)   // Ensure d3 layer in front of map
                .attr("class","d3_layer")
                //.on("click",mouseClickMap);
        }


    function createForestPlot(){
        //var forest_plot = document.getElementById("forest_plot")
        forest_plot = d3.select("#forest_plot")
        
        var margin = 10 


        var height = (forest_plot.attr("height") - 2*margin);
        var width = (forest_plot.attr("width") - 2*margin)

        console.dir(forest_plot)
        console.log("height forest plot = "+height)
        console.log("width forest plot = "+width)

   

        forest_valueScale = d3.scaleLinear().range([0, width])
        forest_positionScale = d3.scaleLinear().range([height, 0]);
        forest_positionScale.domain([-2, initial_data.length+2])    //We want to not have the first study right on the axis, so we space it out
        forest_valueScale.domain([-0.05, max_ci_seroprevalence]);


        //Add the X-axis
        forest_plot.append("g")
            .attr("class","axis")
            .attr("id","forest_x_axis")
            .attr("transform", "translate("+margin+"," + height + ")")
            .call(d3.axisBottom(forest_valueScale));

        // Add the Y Axis
        forest_plot.append("g")
            .attr("class","axis")
            .attr("transform", "translate("+margin+",0)")
            .call(d3.axisLeft(forest_positionScale).tickValues([]));

    }

    function createForest(input_data){
        var margin = 10
        var forest = forest_plot.selectAll(".forest_dot")
            .data(input_data, function(d) { return d.properties.location_id; });

        forest.exit().remove()
        forest.enter()
            //.append("circle")
            .append("path")
            .attr("class", "forest_dot")
            .attr("id",function(d,i){
                return "f_"+d.id
            })
            .on("mouseover", function(d){handleMouseOver(d,""+this.id)})
            .on("mouseout", function(d){handleMouseOut(d,""+this.id)})
        .merge(forest)
            .transition()
            .duration(transition_time)
            .attr("d", d3.symbol()
                .size(40)
                .type(function(d) { 
                    return(getShape(d.properties.study_info))
                })

            )
            //.attr("class","dots")
            //.attr("r", 3)
            //.attr("cx", function(d) { return forest_valueScale( parseInt(d.properties.location_id)); })
            //.attr("cx", function(d,i) { return 4*i; })
            //.attr("cy", function(d) { return forest_positionScale(d.properties.mean); })
            .attr("transform", function(d,i) {
                let y = forest_positionScale(i)
                let x
                if(variable_focus == possible_focus[0]){
                    x = forest_valueScale(d.properties.mean)
                }
                else{
                    x = forest_valueScale(d.properties.IFR_mean)
                }
                x += margin
                let coordinates = ""+x+","+y
                return "translate("+coordinates+")"
            })

        //render();

        var forest_bars = forest_plot.selectAll(".forest_bars")
            .data(input_data, function(d) { return d.properties.location_id; });
        forest_bars.exit().remove()
        forest_bars.enter()
            //.append("circle")
            .append("rect")
            .attr("height", 2)
            .attr("class", "forest_bars")
            //.attr("r", 3)
            .attr("id",function(d,i){
                return "b_"+d.id
            })
            .on("mouseover", function(d){ handleMouseOver(d,""+this.id)})
            .on("mouseout", function(d){handleMouseOut(d,""+this.id)})
            .merge(forest_bars)
            .transition()
            .duration(transition_time)
            .attr("y", function(d,i) { return (forest_positionScale(i)-1); })
            .attr("x", function(d,i) { 
                let x
                if(variable_focus == possible_focus[0]){
                    x = forest_valueScale(d.properties.p025)
                }
                else{
                    x = forest_valueScale(d.properties.IFR_p025)
                }
                x +=margin
                return x

            })
            .attr("width", function(d) { 
                let x_min
                let x_max
                if(variable_focus == possible_focus[0]){
                    x_min = forest_valueScale(d.properties.p025)
                    x_max= forest_valueScale(d.properties.p975)
                }
                else{
                    x_min = forest_valueScale(d.properties.IFR_p025)
                    x_max= forest_valueScale(d.properties.IFR_p975)

                }
                return (x_max-x_min)
            })
        /*forest_plot.selectAll("dot")
            .data(data_to_display)
        .enter().append("circle")
            .attr("r", 5)
            .attr("cx", function(d) { return forest_valueScale(d.properties.location_id); })
            .attr("cy", function(d) { return forest_positionScale(d.properties.mean); });*/

    }

    function handleMouseOver(datum,id){
        id = id.split("_")[1]   //We only need the number
        let id_to_select = "#f_"+id
        let selection = d3.select(id_to_select)
        selection.classed('hovered', true)
        id_to_select = "#d_"+id
        selection = d3.select(id_to_select)
        selection.classed('hovered', true)
        id_to_select = "#b_"+id
        selection = d3.select(id_to_select)
        selection.classed('hovered', true)

        let h = d3.select("#forest_plot").attr("height")
        console.log("h = "+h)

        var location
        if(datum.properties.location_label == "National Study"){
            location = datum.properties.country +" [National Study]"
        }
        else{
            location = (datum.properties.location_label + " ["+datum.properties.country+"]")

        }

        let dates = toShortString(datum.properties.start_date) + " -- " + toShortString(datum.properties.end_date)
        
        let links = ""
        if(datum.properties.link_one != '' && datum.properties.link_one !=null){
            links += "<a href='"+datum.properties.link_one+"'>Link1</a>"
        }
        if(datum.properties.link_two != '' && datum.properties.link_two !=null){
            links += "; <a href='"+datum.properties.link_two+"'>Link2 </a>"
        }

        let seroprevalence_info = ""+parseFloat(datum.properties.mean).toFixed(2)+ " ["+parseFloat(datum.properties.p025).toFixed(2)+" ; "+parseFloat(datum.properties.p975).toFixed(2)+"]"
        let ifr_info = "NA"
        if(datum.properties.IFR_mean != null ){
            ifr_info = ""+parseFloat(datum.properties.IFR_mean).toFixed(2)+ " ["+parseFloat(datum.properties.IFR_p025).toFixed(2)+" ; "+parseFloat(datum.properties.IFR_p975).toFixed(2)+"]"
        }
        
        document.getElementById("locationInfo").textContent = location
        document.getElementById("typeInfo").textContent = datum.properties.study_info
        document.getElementById("seroprevalenceInfo").textContent = seroprevalence_info
        document.getElementById("IFRInfo").textContent = ifr_info
        document.getElementById("assayInfo").textContent = datum.properties.assay_name
        document.getElementById("datesInfo").textContent = dates
        document.getElementById("sourcesInfo").innerHTML = datum.properties.source +"<br/>"+ links
        //d3.select("#sourcesInfo").html = datum.properties.source + links
        
    }

    function handleMouseOut(datum,id){
        id = id.split("_")[1]   //We only need the number
        let id_to_select = "#f_"+id
        let selection = d3.select(id_to_select)
        selection.classed('hovered', false)
        //d3.select(graph_object).classed('hovered', true);
        id_to_select = "#d_"+id
        selection = d3.select(id_to_select)
        selection.classed('hovered', false)
        id_to_select = "#b_"+id
        selection = d3.select(id_to_select)
        selection.classed('hovered', false)

    }

    function createLegendFinal(){

        var data = [age_specific_ifr,population_ifr,age_specific_prevalence,overall_prevalence]
        let id= "#legend_shape"
        var scale = 0.6
        var font_size_sub = (1.1*scale)+"em"
        var font_size = scale+"em"
        var draw_size = 100
        var svg_size = 20

        for (var i=0 ; i < data.length ; i ++){
            console.log("Data #"+i)
            let id_to_select = id+(i+1)
            console.log("id_to_select = "+id_to_select)
            let select = d3.select(id_to_select)
            console.dir(select)
            select.append("svg")
            .attr('width', svg_size+'px')
            .attr('height', svg_size+'px')
                .append("path")
                .attr("class", "legend_dots")
                .style("fill", function(){
                    return(colorScale(20))
                })
                .attr("d", d3.symbol()
                    .size(draw_size)
                    .type(function(){ 
                        console.log("data[i] = "+data[i])
                        console.log("getShape = "+getShape(data[i]))
                        return(getShape(data[i]))
                    })

                )
                .attr("transform","translate("+svg_size/2+","+svg_size/2+")")

        }

        var legend2_x_start = 15

        //Now we want to make the continuous scale legend
        
        var width_rectangle = scale*30
        var height_rectangle = scale*100
        var x_extra_offset = scale*12

        var legendDiv = d3.select("#gradient_legend_svg")

        var legendSvg = legendDiv.append("svg").attr("id","svg_gradient")


        //legendSvg.style("display","block").style("margin","auto")

        var y_offset = 20

        let max_text = parseFloat(max_seroprevalence).toFixed(2)

        var gradient = legendSvg.append("defs").append("linearGradient")
            .attr("id", "mygrad")//id of the gradient
            .attr("x1", "0%")
            .attr("x2", "0%")
            .attr("y1", "0%")
            .attr("y2", "100%")//since its a vertical linear gradient 
            ;
            gradient.append("stop")
            .attr("offset", "0%")
            .style("stop-color", color1)
            .style("stop-opacity", 1)

            gradient.append("stop")
            .attr("offset", "100%")
            .style("stop-color", color2)
            .style("stop-opacity", 1)


        legendSvg.append("rect")
            .attr("width", width_rectangle)
            .attr("height", height_rectangle)
            .style("fill", "url(#mygrad)")
            .attr("x",scale*(legend2_x_start+x_extra_offset))
            .attr("y",scale*(y_offset+60))

        legendSvg.append("text")
            //.attr("x",scale*(legend2_x_start+x_extra_offset))
            .attr("x",scale*(legend2_x_start))
            .attr("y",scale*(45+y_offset))
            .text("00.00%")
            .attr("class","legend_text")
            .style("fill",text_color)

        legendSvg.append("text")
            //.attr("x",scale*(legend2_x_start+x_extra_offset))
            .attr("x",scale*(legend2_x_start))
            .attr("y",scale*(height_rectangle+130+y_offset))
            .text(max_text+"%")
            .attr("id","legend_gradient_max")
            .attr("class","legend_text")
            .style("fill",text_color)

    }

    function createLegend(){
        
        var scale = 0.75

        var y_offset_to_middle = scale*5 ;
        var x_offset = scale*15 ;
        var y_offset = scale*40 ;    //These two offsets represent the title

        var font_size = scale+"em"
        var font_size_header = (1.3*scale)+"em"
        var font_size_sub = (1.1*scale)+"em"

        var additional_height = 0 
        if(encode_national_studies){
            additional_height = 30
        }

        var legendDiv = d3.select('#mapLegend').append('div')
            .attr('width', (scale*360)+'px')
            .attr('height', (scale*(200+additional_height))+'px')
            .style("z-index",110)
            .style("opacity",1)
            .attr("class","legend")
            .style("background-color",legend_color)
            .style("position","absolute")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("border-color","white")

        var data = [age_specific_ifr,population_ifr,age_specific_prevalence,overall_prevalence]


        //First we create the legend for the shapes
        legendSvg = legendDiv.append("svg")
            .attr('width', (scale*360)+'px')
            .attr('height', (scale*(200+additional_height))+'px')
            .style("z-index",110)
            .attr("class","legend")
            .style("background-color",legend_color)
            .style("opacity",1)
            .style("border-width","2px")
            .style("border-color","white");

        legendSvg.append("text")
            .attr("x",scale*5)
            .attr("y",scale*20)
            .text("Legend:")
            .style("font-size",font_size_header)
            .style("fill",text_color)
            .attr("class","legend_text_header legend_text")

        legendSvg.append("text")
            .attr("x",scale*(5+x_offset))
            .attr("y",scale*50)
            .text("Study type")
            .style("fill",text_color)
            .style("font-size",font_size_sub)
            .attr("class","legend_text_sub legend_text")

        legendSvg.selectAll(".legend_dots").data(data).enter().append("path")
            .attr("class", "legend_dots")
            .style("fill", function(d){
                return(colorScale(20))
            })
            .attr("d", d3.symbol()
                .size(scale*200)
                .type(function(d) { 
                    return(getShape(d))
                })

            )
            .attr("transform",function(d,i){
                let x = scale*10 +x_offset
                let y = scale*((i+1)*30) + y_offset
                return ("translate("+x+","+y+")")
            });
        legendSvg.selectAll(".text").data(data).enter().append("text")
            .attr("x", (scale*25)+ x_offset)
            .attr("y",function(d,i){
                let y = scale*(((i+1)*30) + y_offset_to_middle) + y_offset
                return y ;
            })
            .text(function(d){
                return d ;
            })
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);

        if(encode_national_studies){
            //Now we create the legend for the national VS non-national studies
            //We add it at the bottom as an extra line to show how national studies are highlighted
            let y_position = scale*(4*30) + 1/scale*60
            legendSvg.selectAll(".legend_dots_national").data(data).enter().append("path")
                .attr("class", "legend_dots_national national")
                .style("fill", function(d){
                    return(colorScale(20))
                })
                .attr("d", d3.symbol()
                    .size(scale*200)
                    .type(function(d) { 
                        return(getShape(d))
                    })

                )
                .attr("transform",function(d,i){
                    let x = scale*(10 + (i*25) + x_offset)
                    let y = scale*(y_position+y_offset)
                    return ("translate("+x+","+y+")")
                });

            legendSvg.append("text")
                .attr("x", scale*(110+x_offset))
                .attr("y", function(){
                    return (scale*(y_position + y_offset_to_middle + y_offset))
                })
                .text("National Studies")
                .attr("class","legend_text")
                .style("fill",text_color)
                .style("font-size",font_size);

        }
        
        legend2_x_start = scale*300

        //Now we want to make the continuous scale legend
        
        var width_rectangle = scale*30
        var height_rectangle = scale*100
        var x_extra_offset = scale*30

        var gradient = legendSvg.append("defs").append("linearGradient")
            .attr("id", "mygrad")//id of the gradient
            .attr("x1", "0%")
            .attr("x2", "0%")
            .attr("y1", "0%")
            .attr("y2", "100%")//since its a vertical linear gradient 
            ;
            gradient.append("stop")
            .attr("offset", "0%")
            .style("stop-color", color1)
            .style("stop-opacity", 1)

            gradient.append("stop")
            .attr("offset", "100%")
            .style("stop-color", color2)
            .style("stop-opacity", 1)

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start))
            .attr("y",scale*50)
            .attr("id","gradient_legend")
            .style('fill', '')
            .text("Prevalence (in %)")
            .attr("class","legend_text_sub legend_text")
            .style("fill",text_color)
            .style("font-size",font_size_sub);

        legendSvg.append("rect")
            .attr("width", width_rectangle)
            .attr("height", height_rectangle)
            .style("fill", "url(#mygrad)")
            .attr("x",scale*(legend2_x_start+x_extra_offset))
            .attr("y",scale*(y_offset+40))

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start+(width_rectangle/2)-7+x_extra_offset))
            .attr("y",scale*(45-10+y_offset))
            .text("0%")
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start+(width_rectangle/2)-13+x_extra_offset)-10)
            .attr("y",scale*(height_rectangle+80+y_offset))
            .text(max_seroprevalence+"%")
            .attr("id","legend_gradient_max")
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);



    }

    function createDots(input_data) {
        console.dir(input_data)
        //d3.selectAll(".d3_layer").remove(); //For when we update the map
        var svg = d3.select(".d3_layer")
        svg.selectAll(".dots").remove(); //For when we update the map

        var dots = svg.selectAll(".dots")
            .data(input_data,function(d) { return d.properties.location_id; });


        dots.exit().remove()
        dots.enter()
            .append("path")
            //.attr("class","dots")
            .attr("class", function(d){
                if(d.properties.location_label == "National Study"){
                    if(encode_national_studies){
                        return "dots national"
                    } 
                }
                return "dots"
            })
            .attr("id", function(d,i){
                return("d_"+d.id)
            })
            .style("fill", function(d){
                if(variable_focus == possible_focus[0]){
                    return(colorScale(d.properties.mean));
                }
                else{
                    return(colorScale(d.properties.IFR_mean)) 
                }
                
            })
            .attr("d", d3.symbol()
                .size(200)
                .type(function(d) { 
                    return(getShape(d.properties.study_info))
                })

            )
            //.on("click",mouseClickData)
            .on("mouseover", function(d){handleMouseOver(d,""+this.id)})
            .on("mouseout", function(d){handleMouseOut(d,""+this.id)});

        render();
      }

      // Projection method:
      // Project geojson coordinate to the map's current state
      function project(d) {
        return map.project(new maplibregl.LngLat(d[0], d[1]));
      }

      // Render method redraws lines
      function render() {
        d3.selectAll(".dots")
            .attr("transform", function(d) {
                let projection = project(d.geometry.coordinates)
                let coordinates = ""+projection.x+","+projection.y;
                return "translate("+coordinates+")"
            });
        if(tooltip_ref_point_coordinates!=null){
            let coordinates = project(tooltip_ref_point_coordinates)
            var tooltip_x = (coordinates.x+tooltipXOffset)+"px"
            var tooltip_y = (coordinates.y+tooltipYOffset)+"px"
            d3.selectAll(".tooltip")
                .style("left", tooltip_x)
                .style("top", tooltip_y)
        }
        
      }





        function getShape(input){
            if(display_study_type){
                if (input == age_specific_ifr){
                    return d3.symbolCircle;
                }
                if(input == population_ifr){
                    return d3.symbolSquare;
                }
                if(input == age_specific_prevalence){
                    return d3.symbolDiamond;
                }
                if(input == overall_prevalence){
                    return d3.symbolCross;
                }
                console.log("Error on study type")
            }
            /*else if(display_age_classification){
                if (input == "Uniform"){

                }
                if(input == "Declining"){

                }
                if(input == "Increasing"){

                }
            }*/
           
        }


      function makeGeoJson(input_data){
        csv2geojson.csv2geojson(input_data, {
            latfield: 'latitude',
            lonfield: 'longitude',
            delimiter: ','
        }, function(err, output_data) {
            if(err != null){
                console.log("There was an error in the encoding to GeoJson")
                console.dir(err)
            }
            else{
                initial_data = output_data
                for(var i = 0 ; i < output_data.features.length ; i ++){
                    output_data.features[i].id = i
                }
                data_to_display = output_data.features
                if(variable_focus == possible_focus[0]){
                    data_to_display.sort(sortBy('mean'));
                }
                else{
                    data_to_display.sort(sortBy('IFR_mean'));
                }
                createDots(data_to_display)
                createForest(data_to_display)
            }
            

        });
      }
    </script>
  </body>
</html>