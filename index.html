<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"/>
<!--<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.0/mapbox-gl.js"></script>
<link href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.0/mapbox-gl.css" rel="stylesheet"/>-->
<script src="https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://npmcdn.com/csv2geojson@latest/csv2geojson.js"></script>

<style>
    body {
        margin: 0;
        padding: 0;
    }
    h1{
        padding: 2px;
        text-align: center;
        font-size: 1.6em;
    }
    h2{
        text-align: center;
        font-size: 1.3em;
    }
    fieldset.inline {
        display: inline;
        vertical-align:top;
        text-align: left;
    }
    p{
        margin: 2em;
    }

    #controls{
        text-align: center;
    }

    #map {
        position: absolute;
        height: 80%;
        width: 100%;
        margin-top: 1em;
    }

    .tooltip{
        z-index: 100;
    }
    .dots{
        stroke: black;
        stroke-width: 0.5px;
    }
    .national{
        stroke: white;
        stroke-width: 4px;
    }
    .legend{
        z-index: 120;
    }
    .legend_text{
        color: white;
    }
    .legend_text_header{
        font-size: 1.3em;
    }
    .legend_text_sub{
        font-size: 1.1em;
    }

    #forest_plot_div{
        position: absolute;
    }

    .hovered{
        stroke: pink;
        stroke-width: 5px;
    }
</style>
</head>
  <body>
    <div id="Text">
        <h1> Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications </h1>
        <h2> Interactive map of all included studies </h2>
        <p>This map displays the location and seroprevalence of all the studies included in our paper "<a href="https://www.medrxiv.org/content/10.1101/2021.09.29.21264325v1.full-text">Assessing the Burden of COVID-19 in Developing Countries: Systematic Review, Meta-Analysis, and Public Policy Implications.</a>"<br> You can click on a study for more information.</p>
    </div>
    <div id="controls">
        <div id="inclusion">
            <div id="data_to_show">
                Visualize
                    <select name="encodeVariable" id="encodeVariable" onchange="changeEncodeVariable()"> 
                    </select> 
            </div>
            <div id="date_div_start">
                Assay Starts -- Min Date <input type="date" id="minDateInputStart" name="minDateInputStart" onchange="changeMinStart()" value="2018-11-23"></td>
                Max Date <input type="date" id="maxDateInputStart" name="maxDateInputStart" onchange="changeMaxStart()" value="2020-11-23"></td>
            </div>
            <div id="date_div_end">
                Assay Ends -- Min Date <input type="date" id="minDateInputEnd" name="minDateInputEnd" onchange="changeMinEnd()" value="2018-11-23"></td>
                Max Date <input type="date" id="maxDateInputEnd" name="maxDateInputEnd" onchange="changeMaxEnd()" value="2020-11-23"></td>
            </div>
            <fieldset class="inline">
                <legend>Data location (uncheck to exclude):</legend>
                <div>
                  <input type="checkbox" id="national" name="national" checked onchange="changeNational()">
                  <label for="national">National</label>
                </div>
                <div>
                  <input type="checkbox" id="local" name="local" checked onchange="changeLocal()">
                  <label for="local">Local (city or county)</label>
                </div>
            </fieldset>

            <fieldset class="inline">
                <legend>Data Source (uncheck to exclude):</legend>
                <div>
                  <input type="checkbox" id="Age-specific-IFR" name="Age-specific-IFR" checked onchange="changeAgeIFR()">
                  <label for="Age-specific-IFR">Age-specific-IFR</label>
                </div>
                <div>
                  <input type="checkbox" id="Population-IFR" name="Population-IFR" checked onchange="changePopulationIFR()">
                  <label for="Population-IFR">Population-IFR</label>
                </div>
                <div>
                  <input type="checkbox" id="Age-specific-Prevalence" name="Age-specific-Prevalence" checked onchange="changeAgePrevalence()">
                  <label for="Age-specific-Prevalence">Age-specific-Prevalence</label>
                </div>
                <div>
                    <input type="checkbox" id="Overall-Prevalence" name="Overall-Prevalence" checked onchange="changeOverallPrevalence()">
                    <label for="Overall-Prevalence">Overall-Prevalence</label>
                </div>
            </fieldset>

            <!--
            <fieldset class="inline">
                <legend>Prevalence distribution accross ages (uncheck to exclude):</legend>
                <div>
                  <input type="checkbox" id="uniform" name="uniform" checked onchange="changeUniform()">
                  <label for="uniform">Uniform Prevalence By Age</label>
                </div>
                <div>
                  <input type="checkbox" id="declining" name="declining" checked onchange="changeDecreasing()">
                  <label for="declining">Declining Prevalence By Age</label>
                </div>
                <div>
                  <input type="checkbox" id="increasing" name="increasing" checked onchange="changeIncreasing()">
                  <label for="increasing">Increasing Prevalence By Age</label>
                </div>
            </fieldset>
            -->
        </div>
    </div>
    <div width="600" height="500"><svg width="600" height="500", id="forest_plot"></svg></div>
    <div id="map"></div>
    
    <script>



        /****** Data handling functions & variables*****/
        var initial_data ;
        var data_to_display ;
        var include_age_specific_IFR = true ; 
        var include_population_IFR = true ;
        var include_overall_prevalence = true ;
        var include_age_specific_prevalence = true ;

        var include_national = true ;
        var include_local = true ;

        var include_uniform = true ;
        var include_decreasing = true ;
        var include_increasing = true ;

        const encode_national_studies = false

        var possible_focus = ["Seroprevalence","IFR"]
        var possible_properties = ["mean","IFR_mean"] 

        var focus_elem = document.getElementById("encodeVariable")
        for(i in possible_focus) {focus_elem.add(new Option(possible_focus[i],possible_focus[i]));}

        var variable_focus = possible_focus[0]

        var min_date_start = null
        var max_date_start = null
        var min_date_end = null 
        var max_date_end = null 



        const age_specific_ifr = "Age-Specific IFR"
        const population_ifr = "Population IFR"
        const age_specific_prevalence = "Age-Specific Prevalence"
        const overall_prevalence = "Overall Prevalence"

        function changeAgeIFR() {
            include_age_specific_IFR = !include_age_specific_IFR
            filterData()
        }
        function changeAgePrevalence(){
            include_age_specific_prevalence = !include_age_specific_prevalence
            filterData()
        }
        function changeOverallPrevalence(){
            include_overall_prevalence = !include_overall_prevalence
            filterData()
        }
        function changePopulationIFR(){
            include_population_IFR = !include_population_IFR
            filterData()
        }
        function changeNational(){
            include_national = !include_national
            filterData()
        }
        function changeLocal(){
            include_local = !include_local
            filterData()
        }
        function changeUniform(){
            include_uniform = !include_uniform
            filterData()
        }
        function changeDecreasing(){
            include_decreasing = !include_decreasing
            filterData()
        }
        function changeIncreasing(){
            include_increasing = !include_increasing
            filterData()
        }


        function changeMinStart(){
            let v = document.getElementById("minDateInputStart").value;
            min_date_start = parseISODate(v);
            filterData();
        }

        function changeMinEnd(){
            let v = document.getElementById("minDateInputEnd").value;
            min_date_end = parseISODate(v);
            filterData();
        }

        function changeMaxStart(){
            let v = document.getElementById("maxDateInputStart").value;
            max_date_start = parseISODate(v);
            filterData();
        }
        function changeMaxEnd(){
            let v = document.getElementById("maxDateInputEnd").value;
            max_date_end = parseISODate(v);
            filterData();
        }


        // Parse and validate a date in format yyyy-mm-dd
        // Note that a date without a timezone is treated as LOCAL since
        // the HTML spec is consistent with ISO 8601
        function parseISODate(s){
            var b = s.split(/\D/);
            var d = new Date(b[0], --b[1], b[2]);
            return d && d.getMonth() == b[1]? d : new Date(NaN);
        }

        function changeEncodeVariable(){
            var value = focus_elem.options[focus_elem.selectedIndex].value;
            //Seroprevalence, column mean
            variable_focus = value
            if (variable_focus == possible_focus[0]){

            }
            else{

            }
            filterData()
            updateLegend(variable_focus)
        }

        //Returns false if the element is not between specified dates
        function filterByDate(elem){
            if( elem.properties.start_date < min_date_start || elem.properties.start_date > max_date_start){
                return false
            }
            if( elem.properties.end_date < min_date_end || elem.properties.end_date > max_date_end){
                return false
            }
            return true 
        }

        function filterData(){
            data_to_display =  []
            for(var i = 0 ; i < initial_data.features.length ; i++){
                let elem = initial_data.features[i]
                if(include_age_specific_IFR == false && elem.properties.study_info == age_specific_ifr){
                    continue
                }
                if(include_population_IFR == false && elem.properties.study_info == population_ifr){
                    continue
                }
                if(include_age_specific_prevalence == false && elem.properties.study_info == age_specific_prevalence){
                    continue                 
                }
                if(include_overall_prevalence == false && elem.properties.study_info == overall_prevalence){
                    continue
                }
                if(include_local == false && elem.properties.location_label != "National Study"){
                    continue
                }
                if(include_national == false && elem.properties.location_label == "National Study"){
                    continue
                }
                /*if(include_uniform == false && elem.properties.AgeClassification == "Uniform"){
                    continue
                }
                if(include_decreasing == false && elem.properties.AgeClassification == "Declining"){
                    continue
                }
                if(include_increasing == false && elem.properties.AgeClassification == "Increasing"){
                    continue
                }*/

                //If we focus on Seroprevalece, no problem, but if we focus on IFR, some elements won't have a value, we should remove them
                if(variable_focus == possible_focus[1]){
                    if(elem.properties.IFR_mean == ""){
                        continue
                    }
                }

                if(filterByDate(elem) == false){
                    continue 
                }
                data_to_display.push(elem)
            }
            createDots(data_to_display)
            createForest(data_to_display)

        }

        function create_date(input_string){
            input_string = input_string.split("/")
            let day = +input_string[1]
            let month = +input_string[0]
            let year = +input_string[2]
            let date = new Date(year, month, day)
            return date
        }

        function initialize_max_min_dates(type,date){
            if(type=="start"){
                if(min_date_start == null){
                    min_date_start = date
                }
                if(max_date_start == null){
                    max_date_start = date
                }
                if(date < min_date_start){
                    min_date_start = date
                }
                if(date > max_date_start){
                    max_date_start = date
                }
            }
            else{
                if(min_date_end == null){
                    min_date_end = date
                }
                if(max_date_end == null){
                    max_date_end = date
                }
                if(date < min_date_end){
                    min_date_end = date
                }
                if(date > max_date_end){
                    max_date_end = date
                }
            }
        }


        function parseDates(data){
            for (var i = 0 ; i < data.features.length ; i++){
                let elem = data.features[i].properties
                let date = create_date(elem.start_date)
                elem.start_date = date
                initialize_max_min_dates("start",date)

                date = create_date(elem.end_date)
                elem.end_date = date 
                initialize_max_min_dates("end",date)
            }

            document.getElementById("minDateInputStart").value = (toISOString(min_date_start).substr(0,10))
            document.getElementById("maxDateInputStart").value = (toISOString(max_date_start).substr(0,10))
            document.getElementById("minDateInputEnd").value = (toISOString(min_date_end).substr(0,10))
            document.getElementById("maxDateInputEnd").value = (toISOString(max_date_end).substr(0,10))
        }


        /* This function will be called instead of the function in the Date object that does not leave the time in local timezone.*/
        function toISOString(date) {
          var tzo = -date.getTimezoneOffset(),
              dif = tzo >= 0 ? '+' : '-',
              pad = function(num) {
                  var norm = Math.floor(Math.abs(num));
                  return (norm < 10 ? '0' : '') + norm;
              };

          return date.getFullYear() +
              '-' + pad(date.getMonth() + 1) +
              '-' + pad(date.getDate()) +
              'T' + pad(date.getHours()) +
              ':' + pad(date.getMinutes()) +
              ':' + pad(date.getSeconds()) +
              dif + pad(tzo / 60) +
              ':' + pad(tzo % 60);
        }

        function toShortString(date){
            return (date.getFullYear()+"/"+(date.getMonth()+1)+"/"+date.getDate())
        }


        /****** D3 bits*****/


        var color1 = "rgba(255,255,255,0.85)"
        var color2 = "rgba(165,15,21,0.85)"

        var tooltip_ref_point_coordinates = null ;

        var colorScale = d3.scaleLinear()
            .range([color1, color2]); //"rgba(103,0,13,0.8)"]);

        var max_value = 100

        var tooltipXOffset = 10 ;
        var tooltipYOffset = -50 ;

        var clickedData = false ;

        var display_study_type = true ;
        var offsetYTooltip = document.getElementById("Text").clientHeight + document.getElementById("controls").clientHeight;
        //var offsetYTooltip = document.getElementById("Text").offsetHeight + document.getElementById("controls").offsetHeight;

        var formatNumber = d3.format('.2f');

        var map_style = "positron"

        let style_link,legend_color,text_color,stroke_color

        if(map_style == "positron"){
            style_link = "https://api.maptiler.com/maps/positron/style.json"
            legend_color = "rgba(195,200,202,0.8)"
            text_color = 'rgba(0,0,0,1)'
        }

        if(map_style == "dark_matter"){
            style_link = "https://api.maptiler.com/maps/darkmatter/style.json"
            legend_color = "rgba(0,0,0,0.8)"
            text_color = 'rgba(255,255,255,1)'
        }

        style_link+="?key=vzWoiH8YygJqMjY0TcSt "

        var forest_valueScale 
        var forest_positionScale 

        var forest_plot



        function updateLegend(value_for_gradient){
            var gradient_legend = document.getElementById('gradient_legend')
            gradient_legend.textContent = value_for_gradient + " (in %)"
        }

        var Tooltip = d3.select("#map")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("background-color", "pink")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")
                .style("position","absolute")
        
        var mouseClickData = function(d) {

            clickedData = true ;
            Tooltip.style("opacity", 1)
            /*tooltip_x = (d3.event.pageX+10) + "px"
            tooltip_y = (d3.event.pageY-offsetYTooltip) + "px"*/

            var projection = project(d.geometry.coordinates)
            tooltip_ref_point_coordinates = d.geometry.coordinates ;
            var tooltip_x = (projection.x+tooltipXOffset)+"px"
            var tooltip_y = (projection.y+tooltipYOffset)+"px"
            var location
            if(d.properties.location_label == "National Study"){
                location = d.properties.country +" [National Study]"
            }
            else{
                location = (d.properties.location_label + " ["+d.properties.country+"]")

            }

            let dates = toShortString(d.properties.start_date) + " -- " + toShortString(d.properties.end_date)
            let links = ". "
            if(d.properties.link_one != ''){
                links += "<a href='"+d.properties.link_one+"'>Link1</a>"
            }
            if(d.properties.link_two != ''){
                links += "; <a href='"+d.properties.link_two+"'>Link2 </a>"
            }

            let seroprevalence_info = ""+d.properties.mean+ " ["+d.properties.p025+" ; "+d.properties.p975+" ]"
            let ifr_info = "NA"
            if(d.properties.IFR_mean != ""){
                ifr_info = ""+d.properties.IFR_mean+ " ["+d.properties.IFR_p025+" ; "+d.properties.IFR_p975+" ]"
            }
            

            Tooltip
            .html("Location:<br>"+location + "<br><br>Type:<br>" + d.properties.study_info + "<br><br>Seroprevalence: " + seroprevalence_info+ "<br>IFR: "+ifr_info+"<br><br>Assay name:<br>"+d.properties.assay_name + "<br><br>Dates:<br>" + dates + "<br><br>Source:<br>"+ d.properties.source + links)
            .style("left", tooltip_x)
            .style("top", tooltip_y)
        }
        
        
        var mouseClickMap = function(d) {
            if(!clickedData){
                Tooltip.style("opacity", 0)    
                tooltip_ref_point_coordinates = null ;
            }
            clickedData = false ;
            
        }

        

        /****** Map bits*****/

        //mapboxgl.accessToken = "pk.eyJ1IjoibG9ubmliZXNhbmNvbiIsImEiOiJjamxjaWNpOHQwMHV0M3FwaHhneGhvY2l2In0.7GxI8W_dnTKITNF4hEvZeQ";

        var map;


        /****** Display code *****/

        d3.csv("./map_data.csv")
            .then(function(data){
                initial_data = JSON.parse(JSON.stringify(data))
                //initial_data = data
                updateMaxMinForColorScale(data,"mean")
                createLegend()
                createMap()
                createForestPlot()
                makeGeoJson(data)
                parseDates(initial_data)
                return ;
            })

        function createMap() {
            map = new maplibregl.Map({
            container: "map", // container id
            //style: "mapbox://styles/mapbox/light-v9", // stylesheet location
            //style: "mapbox://styles/lobenichou/cjto9zfpj00jq1fs7gajbuaas?fresh=true",
            //style: "https://api.maptiler.com/maps/darkmatter/style.json?key=vzWoiH8YygJqMjY0TcSt",
            style: style_link,
            zoom: 1.8, // starting zoom
            maxZoom: 10.2,
            });


            map.on("viewreset", render);
            map.on("move", render);
            map.on("moveend", render);

            // Optional: Modify map with d3
            d3.selectAll(".mapboxgl-canvas")
              .style("opacity", 1)
              .style("position", "absolute")
              .style("z-index", 1);

            var container = map.getCanvasContainer();
            var svg = d3
                .select(container)
                .append("svg")
                .attr("width", "100%")
                .attr("height", "2000")
                .style("position", "absolute")
                .style("z-index", 10)   // Ensure d3 layer in front of map
                .attr("class","d3_layer")
                .on("click",mouseClickMap);
        }


    function createForestPlot(){
        //var forest_plot = document.getElementById("forest_plot")
        forest_plot = d3.select("#forest_plot")
        
        var margin = 20 


        console.log("Printing forest_plot")
        console.dir(forest_plot)
        var height = (forest_plot.attr("height") - 2*margin);
        var width = (forest_plot.attr("width") - 2*margin)

        forest_plot.style("margin",margin+"px")
   

        forest_valueScale = d3.scaleLinear().range([0, width])
        forest_positionScale = d3.scaleLinear().range([height, 0]);
        forest_positionScale.domain([-2, initial_data.length])    //We want to not have the first study right on the axis, so we space it out
        forest_valueScale.domain([0, 100]);




        //Add the X-axis
        forest_plot.append("g")
            .attr("class","axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(forest_valueScale));

        // Add the Y Axis
        forest_plot.append("g")
            .attr("class","axis")
            //.attr("transform", "translate("+margin+",0)")
            .call(d3.axisLeft(forest_positionScale));

    }

    function createForest(input_data){
        console.dir(input_data)
        console.log("forest_plot")
        console.dir(forest_plot)
        var forest = forest_plot.selectAll(".forest_dot")
            .data(input_data);

        forest.exit().remove()
        forest.enter()
            //.append("circle")
            .append("path")
            .attr("d", d3.symbol()
                .size(40)
                .type(function(d) { 
                    return(getShape(d.properties.study_info))
                })

            )
            .attr("transform", function(d,i) {
                let x = forest_positionScale(i)
                let y
                if(variable_focus == possible_focus[0]){
                    y = forest_valueScale(d.properties.mean)
                }
                else{
                    y = forest_valueScale(d.properties.IFR_mean)
                }
                let coordinates = ""+x+","+y
                return "translate("+coordinates+")"
            })
            //.attr("class","dots")
            .attr("class", "forest_dot")
            //.attr("r", 3)
            //.attr("cx", function(d) { return forest_valueScale( parseInt(d.properties.location_id)); })
            //.attr("cx", function(d,i) { return 4*i; })
            //.attr("cy", function(d) { return forest_positionScale(d.properties.mean); })
            .attr("id",function(d,i){
                return "f_"+i
            })
            .on("mouseover", function(d,i){handleMouseOver(d,i,this)})
            .on("mouseout", function(d,i){handleMouseOut(d,i,this)});


        //render();

        var forest_bars = forest_plot.selectAll(".forest_bars")
            .data(input_data);
        forest_bars.exit().remove()
        forest_bars.enter()
            //.append("circle")
            .append("rect")
            .attr("class", "forest_bars")
            //.attr("r", 3)
            .attr("y", function(d,i) { return (forest_positionScale(i)-1); })
            .attr("x", function(d,i) { 
                let y 
                if(variable_focus == possible_focus[0]){
                    y = forest_valueScale(d.properties.p975)
                }
                else{
                    y = forest_valueScale(d.properties.IFR_p975)
                }
                return y

            })
            .attr("height", 2)
            .attr("width", function(d) { 
                let y_min
                let y_max
                if(variable_focus == possible_focus[0]){
                    y_min = forest_valueScale(d.properties.p025)
                    y_max= forest_valueScale(d.properties.p975)
                }
                else{
                    y_min = forest_valueScale(d.properties.IFR_p025)
                    y_max= forest_valueScale(d.properties.IFR_p975)

                }
                return (y_min-y_max)
            })
            .attr("id",function(d,i){
                return "b_"+i
            })
            .on("mouseover", function(d,i){handleMouseOver(d,i,this)})
            .on("mouseout", function(d,i){handleMouseOut(d,i,this)});
        /*forest_plot.selectAll("dot")
            .data(data_to_display)
        .enter().append("circle")
            .attr("r", 5)
            .attr("cx", function(d) { return forest_valueScale(d.properties.location_id); })
            .attr("cy", function(d) { return forest_positionScale(d.properties.mean); });*/

    }

    function handleMouseOver(datum,index,graph_object){
        let id_to_select = "#f_"+index
        let selection = d3.select(id_to_select)
        selection.classed('hovered', true)
        id_to_select = "#d_"+index
        selection = d3.select(id_to_select)
        selection.classed('hovered', true)
        id_to_select = "#b_"+index
        selection = d3.select(id_to_select)
        selection.classed('hovered', true)


        console.log("Type = "+datum.properties.study_info)
        
    }

    function handleMouseOut(datum,index,graph_object){
        let id_to_select = "#f_"+index
        let selection = d3.select(id_to_select)
        selection.classed('hovered', false)
        //d3.select(graph_object).classed('hovered', true);
        id_to_select = "#d_"+index
        selection = d3.select(id_to_select)
        selection.classed('hovered', false)
        id_to_select = "#b_"+index
        selection = d3.select(id_to_select)
        selection.classed('hovered', false)

    }

    function createLegend(){
        
        var scale = 0.75

        var y_offset_to_middle = scale*5 ;
        var x_offset = scale*15 ;
        var y_offset = scale*40 ;    //These two offsets represent the title

        var font_size = scale+"em"
        var font_size_header = (1.3*scale)+"em"
        var font_size_sub = (1.1*scale)+"em"

        var additional_height = 0 
        if(encode_national_studies){
            additional_height = 30
        }

        var legendDiv = d3.select('#map').append('div')
            .attr('width', (scale*360)+'px')
            .attr('height', (scale*(200+additional_height))+'px')
            .style("z-index",110)
            .style("opacity",1)
            .attr("class","legend")
            .style("background-color",legend_color)
            .style("position","absolute")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("border-color","white")

        var data = [age_specific_ifr,population_ifr,age_specific_prevalence,overall_prevalence]


        //First we create the legend for the shapes
        legendSvg = legendDiv.append("svg")
            .attr('width', (scale*360)+'px')
            .attr('height', (scale*(200+additional_height))+'px')
            .style("z-index",110)
            .attr("class","legend")
            .style("background-color",legend_color)
            .style("opacity",1)
            .style("border-width","2px")
            .style("border-color","white");

        legendSvg.append("text")
            .attr("x",scale*5)
            .attr("y",scale*20)
            .text("Legend:")
            .style("font-size",font_size_header)
            .style("fill",text_color)
            .attr("class","legend_text_header legend_text")

        legendSvg.append("text")
            .attr("x",scale*(5+x_offset))
            .attr("y",scale*50)
            .text("Study type")
            .style("fill",text_color)
            .style("font-size",font_size_sub)
            .attr("class","legend_text_sub legend_text")

        legendSvg.selectAll(".legend_dots").data(data).enter().append("path")
            .attr("class", "legend_dots")
            .style("fill", function(d){
                return(colorScale(20))
            })
            .attr("d", d3.symbol()
                .size(scale*200)
                .type(function(d) { 
                    return(getShape(d))
                })

            )
            .attr("transform",function(d,i){
                let x = scale*10 +x_offset
                let y = scale*((i+1)*30) + y_offset
                return ("translate("+x+","+y+")")
            });
        legendSvg.selectAll(".text").data(data).enter().append("text")
            .attr("x", (scale*25)+ x_offset)
            .attr("y",function(d,i){
                let y = scale*(((i+1)*30) + y_offset_to_middle) + y_offset
                return y ;
            })
            .text(function(d){
                return d ;
            })
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);

        if(encode_national_studies){
            //Now we create the legend for the national VS non-national studies
            //We add it at the bottom as an extra line to show how national studies are highlighted
            let y_position = scale*(4*30) + 1/scale*60
            legendSvg.selectAll(".legend_dots_national").data(data).enter().append("path")
                .attr("class", "legend_dots_national national")
                .style("fill", function(d){
                    return(colorScale(20))
                })
                .attr("d", d3.symbol()
                    .size(scale*200)
                    .type(function(d) { 
                        return(getShape(d))
                    })

                )
                .attr("transform",function(d,i){
                    let x = scale*(10 + (i*25) + x_offset)
                    let y = scale*(y_position+y_offset)
                    return ("translate("+x+","+y+")")
                });

            legendSvg.append("text")
                .attr("x", scale*(110+x_offset))
                .attr("y", function(){
                    return (scale*(y_position + y_offset_to_middle + y_offset))
                })
                .text("National Studies")
                .attr("class","legend_text")
                .style("fill",text_color)
                .style("font-size",font_size);

        }
        
        legend2_x_start = scale*300

        //Now we want to make the continuous scale legend
        
        var width_rectangle = scale*30
        var height_rectangle = scale*100
        var x_extra_offset = scale*30

        var gradient = legendSvg.append("defs").append("linearGradient")
            .attr("id", "mygrad")//id of the gradient
            .attr("x1", "0%")
            .attr("x2", "0%")
            .attr("y1", "0%")
            .attr("y2", "100%")//since its a vertical linear gradient 
            ;
            gradient.append("stop")
            .attr("offset", "0%")
            .style("stop-color", color1)
            .style("stop-opacity", 1)

            gradient.append("stop")
            .attr("offset", "100%")
            .style("stop-color", color2)
            .style("stop-opacity", 1)

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start))
            .attr("y",scale*50)
            .attr("id","gradient_legend")
            .style('fill', '')
            .text("Prevalence (in %)")
            .attr("class","legend_text_sub legend_text")
            .style("fill",text_color)
            .style("font-size",font_size_sub);

        legendSvg.append("rect")
            .attr("width", width_rectangle)
            .attr("height", height_rectangle)
            .style("fill", "url(#mygrad)")
            .attr("x",scale*(legend2_x_start+x_extra_offset))
            .attr("y",scale*(y_offset+40))

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start+(width_rectangle/2)-7+x_extra_offset))
            .attr("y",scale*(45-10+y_offset))
            .text("0%")
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);

        legendSvg.append("text")
            .attr("x",scale*(legend2_x_start+(width_rectangle/2)-13+x_extra_offset))
            .attr("y",scale*(height_rectangle+80+y_offset))
            .text("100%")
            .attr("class","legend_text")
            .style("fill",text_color)
            .style("font-size",font_size);



    }

    function createDots(input_data) {
        console.dir(input_data)
        //d3.selectAll(".d3_layer").remove(); //For when we update the map
        var svg = d3.select(".d3_layer")
        svg.selectAll(".dots").remove(); //For when we update the map

        var dots = svg.selectAll(".dots")
            .data(input_data);

        console.log("DOTS")
        console.dir(dots)

        dots.exit().remove()
        dots.enter()
            .append("path")
            //.attr("class","dots")
            .attr("class", function(d){
                if(d.properties.location_label == "National Study"){
                    if(encode_national_studies){
                        return "dots national"
                    } 
                }
                return "dots"
            })
            .attr("id", function(d,i){
                return("d_"+i)
            })
            .style("fill", function(d){
                if(variable_focus == possible_focus[0]){
                    return(colorScale(d.properties.mean));
                }
                else{
                    return(colorScale(d.properties.IFR_mean)) 
                }
                
            })
            .attr("d", d3.symbol()
                .size(200)
                .type(function(d) { 
                    return(getShape(d.properties.study_info))
                })

            )
            .on("click",mouseClickData)
            .on("mouseover", function(d,i){handleMouseOver(d,i,this)})
            .on("mouseout", function(d,i){handleMouseOut(d,i,this)});

        render();
      }

      // Projection method:
      // Project geojson coordinate to the map's current state
      function project(d) {
        return map.project(new maplibregl.LngLat(d[0], d[1]));
      }

      // Render method redraws lines
      function render() {
        d3.selectAll(".dots")
            .attr("transform", function(d) {
                let projection = project(d.geometry.coordinates)
                let coordinates = ""+projection.x+","+projection.y;
                return "translate("+coordinates+")"
            });
        if(tooltip_ref_point_coordinates!=null){
            let coordinates = project(tooltip_ref_point_coordinates)
            var tooltip_x = (coordinates.x+tooltipXOffset)+"px"
            var tooltip_y = (coordinates.y+tooltipYOffset)+"px"
            d3.selectAll(".tooltip")
                .style("left", tooltip_x)
                .style("top", tooltip_y)
        }
        
      }



        function updateMaxMinForColorScale(data, column_name){
            var max =d3.max(data, function(d) {  return +d[column_name]; });
            var min =d3.min(data, function(d) {  return +d[column_name];})
            colorScale.domain([0,max_value]);
        }

        function getShape(input){
            if(display_study_type){
                if (input == age_specific_ifr){
                    return d3.symbolCircle;
                }
                if(input == population_ifr){
                    return d3.symbolSquare;
                }
                if(input == age_specific_prevalence){
                    return d3.symbolDiamond;
                }
                if(input == overall_prevalence){
                    return d3.symbolCross;
                }
                console.log("Error on study type")
            }
            /*else if(display_age_classification){
                if (input == "Uniform"){

                }
                if(input == "Declining"){

                }
                if(input == "Increasing"){

                }
            }*/
           
        }


      function makeGeoJson(input_data){
        csv2geojson.csv2geojson(input_data, {
            latfield: 'latitude',
            lonfield: 'longitude',
            delimiter: ','
        }, function(err, output_data) {
            if(err != null){
                console.log("There was an error in the encoding to GeoJson")
                console.dir(err)
            }
            else{
                initial_data = output_data
                createDots(output_data.features)
                createForest(output_data.features)
            }
            

        });
      }
    </script>
  </body>
</html>